;********************************************************
;Servo_Int.inc -- Servo Interrupts
;********************************************************

;TO DO
;1) add the initial 1 ms time as an adjustable "offset"
;2) try 16-bit timer 1
;3) change units to degees or tenths of degree, instead of overflow counts.
;4) adjust idletime so it pads to 20 ms depening on the number of servos.


;-------------------------------------------------------------------------
; This interrupt generated by Timer0 is to create two different time periods:
;
; 1) Inactive period of 18 ms (if PulseOFF = 0) with all servo signals OFF, followed by
; 2) Servo pulse of 1 ms if (PulseOFF = 1), with all servo signals ON.
;
; After that there is a 0-1 ms variable period (PulseON = 0) (made with delays instead of interrupts) 
; to position the servo as follows:
;
; 0 = servo in its most counterclockwise position
; 0.5 = servo in the middle position
; 1.0 = servo in its most clockwise position
;
; During the above period the interrupt timer counts for another 1 ms (PulseOn =1) after which 
; the cycle repeats with the 18 ms inactive period that shuts off any 
; servo signals left on 
;
; So the total duty cycle remains constant at about 20 ms regardles of the number of servos 
; or their individual positions.
;
;-------------------------------------------------------------------------

	bcf	INTCON,T0IF		;Clear TMR0 interrupt flag (do not confuse T0IF -flag- with T0IE -enable mask-)

	call SERVO_Stop	;stop pulse to all servos

	;Check in which stage we are
	btfsc IdleFlag		;flag not set means we are servicing servos
	goto Idle_Time		;flag is set: start idle time (all servo pulses off)

	;Proceed to service each servo in sequence, one per interrupt



Pulse_On:

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
	;DISABLE JOYSTICK SENSING while timing pulses
	call Stop_Pot_Sensing
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	banksel OPTION_REG
	movlw	B'00000010'		;set prescaler to 8
	movwf	OPTION_REG

	;set pulse width based on desired servo position (stored in nextServoAddr register)
	movf	nextServoAddr,w 	;get address of register holding next servo's desired position into W
	movwf	FSR					;store this servo's address from W to indirect register (in RAM)

	bcf 	STATUS, IRP			;select BANK 0 to access INDF indirect addr register
	movf	INDF,w				;get desired position (pulse width for THIS servo) into W
	banksel TMR0				;select timer0 register
	movwf	TMR0				;start timer0 with the pulse width in W
	call SERVO_Start			;start pulse to servo

	incf	nextServoPin, F		;increment next servo's pulse pin
	incf	nextServoAddr, F	;increment next servo's address

	;decrement the servo counter for the next interrupt
	;if zero, then at next interrupt do IdleTime instead of servo pulse
	decfsz	servoCount, F
	 goto	Exit_Servo_ISR	;not last servo yet. Continue sending pulses
	bsf		IdleFlag	;since this is the last servo, do IdleTime at the next interrupt	
	goto 	Exit_Servo_ISR	

;------------------------------
;------------------------------	
Idle_Time:

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
	;ENABLE JOYSTICK SENSING while idle
	call Start_Pot_Sensing
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	
	;reset the beginning address of the memory block for the next servo's position register
	movlw 	SERVO_ADDR 			;starting address of the servo position registers
	movwf	nextServoAddr		; Set address of first servo position register
	clrf	nextServoPin		;set next servo to 0	
	incf	nextServoPin, F		;set next servo to 1

	;reset the number of servos counter
	movlw	NUMSERVOS	;number of servos to control
	movwf	servoCount
	
	;clear flag to start servo pulses on next interrupt
	bcf IdleFlag

	;start idle time now

	;configure timer0 prescaler
	banksel OPTION_REG
	movlw	B'00000111'		;set prescaler to 256 
	movwf	OPTION_REG

	banksel TMR0
;	movlw	240
	movlw	TIME_18ms_INT
	;movlw	TIME_40ms_INT
	movwf	TMR0

;============================================================

Exit_Servo_ISR:
